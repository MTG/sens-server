<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiple sensor data</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/moment@2.29.4/min/moment.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-moment@1.0.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@1.0.0"></script>
    <style>
        #chart-container {
            width: 80%;
            margin: auto;
            padding-top: 20px;
        }
    </style>
</head>
<body>
    <h1>Sensor data for: {{ sensor_ids }}</h1>

    <form method="get" action="">
        <label for="start_time">Start Time:</label>
        <input type="datetime-local" id="start_time" name="start_time" value="{{ start_time|date:'Y-m-d\\TH:i' }}" required>
        <label for="end_time">End Time:</label>
        <input type="datetime-local" id="end_time" name="end_time" value="{{ end_time|date:'Y-m-d\\TH:i' }}"  required>
        <button type="submit">Submit</button>
    </form>

    <div id="chart-container">
        <button id="reset-zoom-button" disabled>Reset Zoom</button>
        <div id="sensorCharts"></div>
    </div>


    <script type="text/javascript">
        const sensorIds = {{ sensor_ids|safe }};
        const sensorChartsWrapper = document.getElementById('sensorCharts');
        const resetZoomButton = document.getElementById('reset-zoom-button');
        const colors = ['blue', 'red', 'green', 'orange', 'purple', 'brown', 'pink', 'gray', 'cyan', 'magenta', 'yellow', 'black'];
        const pointStyles = ['circle', 'cross', 'crossRot', 'dash', 'line', 'rect', 'rectRounded', 'rectRot', 'star', 'triangle'];
        const allCharts = [];
            
        function makeChart(dataMappings, y_min, y_max, y_label) {
            const chartCanvas = document.createElement('canvas');
            const datasets = []
            let k = 0;
            let i = 0;
            sensorIds.forEach(function(sensorId) {
                dataMappings.forEach(function(mapping) {
                    datasets.push({ 
                        label: sensorId + '-' + mapping.label, 
                        data: [], 
                        borderColor: mapping.color ? mapping.color: colors[k%colors.length], 
                        fill: false,
                        borderDash: mapping.dash ? [5, 1]: [0, 0],
                        pointStyle: pointStyles[i % pointStyles.length], // Assign point style
                        dataMapping: mapping,
                        sensorId: sensorId});
                    k += 1;
                });
                i += 1;
            });

            const chart = new Chart(chartCanvas.getContext('2d'), {
                type: 'line',
                data: {
                    datasets: datasets
                },
                options: {
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'minute'
                            },
                            title: {
                                display: true,
                                text: 'Time'
                            }
                        },
                        y: {
                            min: y_min,
                            max: y_max,
                            title: {
                                display: true,
                                text: y_label
                            }
                        }
                    },
                    animation: {
                        duration: 0
                    },
                    plugins: {
                        legend: {
                            labels: {
                                usePointStyle: true,
                            },
                        },
                        zoom: {
                            pan: {
                                enabled: true,
                                mode: 'x',
                            },
                            zoom: {
                                wheel: {
                                    enabled: true,
                                    modifierKey: 'alt',
                                    mode: 'x',
                                },
                                drag: {
                                    enabled: true,
                                },
                                onZoomStart: e => e.point.x > e.chart.chartArea.left && e.point.x < e.chart.chartArea.right && e.point.y > e.chart.chartArea.top && e.point.y < e.chart.chartArea.bottom
                            }
                        }
                    }
                }
            });
            chart.isZommed = false;
            chart.options.plugins.zoom.zoom.onZoom = function(chart) {
                // Stop real-time updates
                chart.isZommed = true;
                resetZoomButton.disabled = false;
            };
            sensorChartsWrapper.appendChild(chartCanvas);
            allCharts.push(chart);
            return chart;
        }

        function adjustChartTimeScale(chart) {
            const startTime = new Date(document.getElementById("start_time").value);
            const endTime =new Date(document.getElementById("end_time").value);
            chart.options.scales.x.min = startTime;
            chart.options.scales.x.max = endTime;
        }

        function resetChartZoom(chart) {
            resetZoomButton.disabled = true;
            chart.isZommed = false;
            chart.resetZoom();
            adjustChartTimeScale(chart);
            chart.update();
        }

        resetZoomButton.onclick = function() {
            allCharts.forEach(function(chart) {
                resetChartZoom(chart);
            });
        };
      
        // Function to fetch data and update the chart
        function fetchSensorData() {
            // Define current start and end time
            const startTime = new Date(document.getElementById("start_time").value);
            const endTime = new Date(document.getElementById("end_time").value);

            // Update charts time axis
            allCharts.forEach(function(chart) {
                if (chart.isZommed !== true){
                    adjustChartTimeScale(chart);
                }
            });
            
            // Loop through each sensor ID and fetch data
            sensorIds.forEach(function (sensorId) {
                fetchIndividualSensorData(sensorId, startTime, endTime);
            });
        }

        async function fetchIndividualSensorData(sensorId, startTime, endTime) {
            const apiUrl = "{{ api_endpoint_url }}" + sensorId + '/time-range/?start_date=' + startTime.toISOString() + '&end_date=' + endTime.toISOString();
            try {
                const response = await fetch(apiUrl);
                const data = await response.json();
                updateChartsFromSensorData(sensorId, data);
                
            } catch (error) {
                console.error("Error fetching sensor data:", error);
            }
        }

        function getValueFromPath(obj, path) {
            const keys = path.split('.');
            let value = obj;
            for (const key of keys) {
                value = value[key];
                if (value === undefined) {
                    return undefined;
                }
            }
            return value;
        }

        function updateChartsFromSensorData(sensorId, data) {
            allCharts.forEach(function(chart) {
                chart.data.datasets.forEach(function(dataset) {
                    if (dataset.sensorId !== sensorId) {
                        return;
                    }
                    const dataMapping = dataset.dataMapping;
                    try {
                        const dataPreparedForUpdate = data.map(function(item) {
                            return { x: new Date(item.sensor_timestamp), y: getValueFromPath(item.data, dataMapping.dataPath) };
                        });
                        updateChartDataset(chart, dataset.label, dataPreparedForUpdate);
                    } catch (error) {
                        console.log("Error updating chart dataset:", dataset.label, error);
                    }
                });
            });           
        }

        // Function to update chart dataset data
        function updateChartDataset(chart, datasetLabel, dataPreparedForUpdate) {
            const datasetIndex = chart.data.datasets.findIndex(function(dataset) {return dataset.label === datasetLabel});
            if (datasetIndex === -1) {
                console.error("Dataset not found in chart:", datasetLabel);
                return;
            }
            // Update chart data
            chart.data.datasets[datasetIndex].data = dataPreparedForUpdate;
            chart.update();
        }

        // Make charts
        makeChart([
            {label: 'Leq', dataPath: 'leq'}
        ], 40, 90, 'dB'); // Leq
        
        makeChart([
            {label: 'Pleasantness', dataPath: 'pleasantness_intg', color: 'blue'},
            {label: 'Pleasantness inst', dataPath: 'pleasantness_inst', color: 'darkBlue', dash: true},
            {label: 'Eventfulness', dataPath: 'eventfulness_intg', color: 'green'},
            {label: 'Eventfulness inst', dataPath: 'eventfulness_inst', color: 'darkGlue', dash: true}
        ], -0.5, 0.5, ''); // Perceptual attributes

        makeChart([
            {label: 'Birds', dataPath: 'sources.birds', color: 'red'},
            {label: 'Construction', dataPath: 'soruces.construction', color: 'orange'},
            {label: 'Dogs', dataPath: 'sources.dogs', color: 'purple'},
            {label: 'Human', dataPath: 'sources.human', color: 'brown'},
            {label: 'Music', dataPath: 'sources.music', color: 'pink'},
            {label: 'Nature', dataPath: 'sources.nature', color: 'gray'},
            {label: 'Siren', dataPath: 'sources.siren', color: 'black'},
            {label: 'Vehicles', dataPath: 'sources.vehicles', color: 'cyan'},
        ], 0.0, 1.0, ''); // Sources

        // When page loads, fetch sensor data
        fetchSensorData();
    </script>
</body>
</html>