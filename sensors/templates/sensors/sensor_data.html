<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sensor Data for {{ sensor_id }}</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/moment@2.29.4/min/moment.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-moment@1.0.0"></script>
    <style>
        #chart-container {
            width: 80%;
            margin: auto;
            padding-top: 20px;
        }
    </style>
</head>
<body>
    <h1>Data for Sensor: {{ sensor_id }}</h1>

    <h2>Real-time data:</h2>
    <div id="chart-container">
        <label for="timeRange">Select Time Range:</label>
        <select id="timeRange" onchange="fetchSensorData();">
            <option value="1">Last Minute</option>
            <option value="60" selected>Last Hour</option>
            <option value="720">Last 12 Hours</option>
            <option value="1440">Last 24 Hours</option>
        </select>
        <div id="sensorCharts"></div>
        <canvas id="sensorChart"></canvas>
    </div>

    <h2>Sensor Data (maximum 1000 data points):</h2>

    <form method="get">
        <label for="start_date">Start Date:</label>
        <input type="date" id="start_date" name="start_date" value="{{ start_date|date:"Y-m-d" }}">
        
        <label for="end_date">End Date:</label>
        <input type="date" id="end_date" name="end_date" value="{{ end_date|date:"Y-m-d" }}">
        
        <button type="submit">Filter</button>
    </form>

    <table border="1">
        <tr>
            <th>Sensor timestamp</th>
            <th>Location</th>
            <th>Data</th>
        </tr>
        {% for data in sensor_data %}
        <tr>
            <td>{{ data.sensor_timestamp }}</td>
            <td>{{ data.location }}</td>
            <td>{{ data.data }}</td>
        </tr>
        {% empty %}
        <tr>
            <td colspan="3">No data available for this sensor in the given date range.</td>
        </tr>
        {% endfor %}
    </table>

    <script type="text/javascript">
        const sensorId = "{{ sensor_id }}"; // Replace with the specific sensor ID or make it dynamic 
        const sensorChartsWrapper = document.getElementById('sensorCharts');

        // Initialize Chart.js charts
        const sourcesChartCanvas = document.createElement('canvas');
        const isoChartCanvas = document.createElement('canvas');

        sensorChartsWrapper.appendChild(isoChartCanvas);
        sensorChartsWrapper.appendChild(sourcesChartCanvas);

        // The ISO chart will contain timeseries for properties:
        // - Pleasantness
        // - Pleasantness Inst
        // - Eventfulness
        // - Eventfulness Inst
        const isoChart = new Chart(isoChartCanvas.getContext('2d'), {
            type: 'line',
            data: {
                datasets: [
                    { label: 'Pleasantness', data: [], borderColor: 'blue', fill: false },
                    { label: 'Pleasantness Inst', data: [], borderColor: 'darkBlue', fill: false },
                    { label: 'Eventfulness', data: [], borderColor: 'green', fill: false },
                    { label: 'Eventfulness Inst', data: [], borderColor: 'darkGreen', fill: false },
                ]
            },
            options: {
                scales: {
                    x: {
                        type: 'time',
                        time: {
                            unit: 'minute'
                        },
                        title: {
                            display: true,
                            text: 'Time'
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'Value'
                        }
                    }
                },
                animation: {
                    duration: 0
                }
            }
        });

        // The sources chart will contain timeseries for the automatically detected sound sources 
        // Possible sound sources include: ['birds', 'construction', 'dogs', 'human', 'music', 'nature', 'siren', 'vehicles']
        const sourcesChart = new Chart(sourcesChartCanvas.getContext('2d'), {
            type: 'line',
            data: {
                datasets: [
                    { label: 'Birds', data: [], borderColor: 'red', fill: false },
                    { label: 'Construction', data: [], borderColor: 'orange', fill: false },
                    { label: 'Dogs', data: [], borderColor: 'purple', fill: false },
                    { label: 'Human', data: [], borderColor: 'brown', fill: false },
                    { label: 'Music', data: [], borderColor: 'pink', fill: false },
                    { label: 'Nature', data: [], borderColor: 'gray', fill: false },
                    { label: 'Siren', data: [], borderColor: 'black', fill: false },
                    { label: 'Vehicles', data: [], borderColor: 'cyan', fill: false },
                ]
            },
            options: {
                scales: {
                    x: {
                        type: 'time',
                        time: {
                            unit: 'minute'
                        },
                        title: {
                            display: true,
                            text: 'Time'
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'Value'
                        }
                    }
                },
                animation: {
                    duration: 0
                }
            }
        });
        
        // Function to fetch data and update the chart
        async function fetchSensorData() {

            // Define current start and end time
            const selectedRange = parseInt(document.getElementById("timeRange").value);
            const currentTime = new Date();
            const startTime = new Date(currentTime - selectedRange * 60 * 1000); // Convert minutes to milliseconds

            // Update chart time axis
            isoChart.options.scales.x.min = startTime;
            isoChart.options.scales.x.max = currentTime;
            sourcesChart.options.scales.x.min = startTime;
            sourcesChart.options.scales.x.max = currentTime;
            
            // Add "start_date" and "end_date" parameters to the apiUrl following this format: .../?start_date=2023-10-01T00:00:00Z&end_date=2025-10-10T23:59:59Z
            // API endpoint to get sensor data filtered by sensor ID and time range
            const apiUrl = "{{ api_endpoint_url }}" + sensorId + '/time-range/?start_date=' + startTime.toISOString() + '&end_date=' + currentTime.toISOString();
            try {
                const response = await fetch(apiUrl);
                const data = await response.json();
                updateChart(data);
            } catch (error) {
                console.error("Error fetching sensor data:", error);
            }
        }

        // Function to update chart data
        function updateChart(data) {

            // Update isoChart data
            isoChart.data.datasets[0].data = [];
            isoChart.data.datasets[1].data = [];
            isoChart.data.datasets[2].data = [];
            isoChart.data.datasets[3].data = [];

            data.forEach(item => {
                const timestamp = new Date(item.sensor_timestamp);
                isoChart.data.datasets[0].data.push({ x: timestamp, y: item.data.pleasantness_intg });
                isoChart.data.datasets[1].data.push({ x: timestamp, y: item.data.pleasantness_inst });
                isoChart.data.datasets[2].data.push({ x: timestamp, y: item.data.eventfulness_intg });
                isoChart.data.datasets[3].data.push({ x: timestamp, y: item.data.eventfulness_inst });
            });

            isoChart.update();

            // Update sourcesChart data
            sourcesChart.data.datasets[0].data = [];
            sourcesChart.data.datasets[1].data = [];
            sourcesChart.data.datasets[2].data = [];
            sourcesChart.data.datasets[3].data = [];
            sourcesChart.data.datasets[4].data = [];
            sourcesChart.data.datasets[5].data = [];
            sourcesChart.data.datasets[6].data = [];
            sourcesChart.data.datasets[7].data = [];

            data.forEach(item => {
                const timestamp = new Date(item.sensor_timestamp);
                sourcesChart.data.datasets[0].data.push({ x: timestamp, y: item.data.sources.birds });
                sourcesChart.data.datasets[1].data.push({ x: timestamp, y: item.data.sources.construction });
                sourcesChart.data.datasets[2].data.push({ x: timestamp, y: item.data.sources.dogs });
                sourcesChart.data.datasets[3].data.push({ x: timestamp, y: item.data.sources.human });
                sourcesChart.data.datasets[4].data.push({ x: timestamp, y: item.data.sources.music });
                sourcesChart.data.datasets[5].data.push({ x: timestamp, y: item.data.sources.nature });
                sourcesChart.data.datasets[6].data.push({ x: timestamp, y: item.data.sources.siren });
                sourcesChart.data.datasets[7].data.push({ x: timestamp, y: item.data.sources.vehicles });
            });

            sourcesChart.update();
        }

        // Fetch data every 1 second to simulate real-time updates
        fetchSensorData()
        setInterval(fetchSensorData, 3000);

    </script>
</body>
</html>