<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sensor Data for {{ sensor_id }}</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/moment@2.29.4/min/moment.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-moment@1.0.0"></script>
    <style>
        #chart-container {
            width: 80%;
            margin: auto;
            padding-top: 20px;
        }
    </style>
</head>
<body>
    <h1>Data for Sensor: {{ sensor_id }}</h1>

    <h2>Real-time data:</h2>
    <div id="chart-container">
        <label for="timeRange">Select Time Range:</label>
        <select id="timeRange" onchange="fetchSensorData();">
            <option value="1">Last Minute</option>
            <option value="60" selected>Last Hour</option>
            <option value="720">Last 12 Hours</option>
            <option value="1440">Last 24 Hours</option>
        </select>
        <div id="sensorCharts"></div>
        <canvas id="sensorChart"></canvas>
    </div>

    <h2>Sensor Data (maximum 1000 data points):</h2>

    <form method="get">
        <label for="start_date">Start Date:</label>
        <input type="date" id="start_date" name="start_date" value="{{ start_date|date:"Y-m-d" }}">
        
        <label for="end_date">End Date:</label>
        <input type="date" id="end_date" name="end_date" value="{{ end_date|date:"Y-m-d" }}">
        
        <button type="submit">Filter</button>
    </form>

    <table border="1">
        <tr>
            <th>Sensor timestamp</th>
            <th>Location</th>
            <th>Data</th>
        </tr>
        {% for data in sensor_data %}
        <tr>
            <td>{{ data.sensor_timestamp }}</td>
            <td>{{ data.location }}</td>
            <td>{{ data.data }}</td>
        </tr>
        {% empty %}
        <tr>
            <td colspan="3">No data available for this sensor in the given date range.</td>
        </tr>
        {% endfor %}
    </table>

    <script type="text/javascript">
        const sensorId = "{{ sensor_id }}"; // Replace with the specific sensor ID or make it dynamic 
        const sensorChartsWrapper = document.getElementById('sensorCharts');

        // Initialize Chart.js charts
        const sourcesChartCanvas = document.createElement('canvas');
        const isoChartCanvas = document.createElement('canvas');

        sensorChartsWrapper.appendChild(isoChartCanvas);
        sensorChartsWrapper.appendChild(sourcesChartCanvas);

        // The ISO chart will contain timeseries for properties:
        // - Pleasantness
        // - Pleasantness Inst
        // - Eventfulness
        // - Eventfulness Inst
        const isoChart = new Chart(isoChartCanvas.getContext('2d'), {
            type: 'line',
            data: {
                datasets: [
                    { label: 'Pleasantness', data: [], borderColor: 'blue', fill: false },
                    { label: 'Pleasantness Inst', data: [], borderColor: 'darkBlue', fill: false },
                    { label: 'Eventfulness', data: [], borderColor: 'green', fill: false },
                    { label: 'Eventfulness Inst', data: [], borderColor: 'darkGreen', fill: false },
                ]
            },
            options: {
                scales: {
                    x: {
                        type: 'time',
                        time: {
                            unit: 'minute'
                        },
                        title: {
                            display: true,
                            text: 'Time'
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'Value'
                        }
                    }
                },
                animation: {
                    duration: 0
                }
            }
        });

        // The sources chart will contain timeseries for the automatically detected sound sources, which can be arbitrary
        const sourcesChart = new Chart(sourcesChartCanvas.getContext('2d'), {
            type: 'line',
            data: {
                datasets: []
            },
            options: {
                scales: {
                    x: {
                        type: 'time',
                        time: {
                            unit: 'minute'
                        },
                        title: {
                            display: true,
                            text: 'Time'
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'Value'
                        }
                    }
                },
                animation: {
                    duration: 0
                }
            }
        });
        
        // Function to fetch data and update the chart
        async function fetchSensorData() {

            // Define current start and end time
            const selectedRange = parseInt(document.getElementById("timeRange").value);
            const currentTime = new Date();
            const startTime = new Date(currentTime - selectedRange * 60 * 1000); // Convert minutes to milliseconds

            // Update chart time axis
            isoChart.options.scales.x.min = startTime;
            isoChart.options.scales.x.max = currentTime;
            sourcesChart.options.scales.x.min = startTime;
            sourcesChart.options.scales.x.max = currentTime;
            
            // Add "start_date" and "end_date" parameters to the apiUrl following this format: .../?start_date=2023-10-01T00:00:00Z&end_date=2025-10-10T23:59:59Z
            // API endpoint to get sensor data filtered by sensor ID and time range
            const apiUrl = "{{ api_endpoint_url }}" + sensorId + '/time-range/?start_date=' + startTime.toISOString() + '&end_date=' + currentTime.toISOString();
            console.log(apiUrl)
            try {
                const response = await fetch(apiUrl);
                const data = await response.json();
                updateChart(data);
            } catch (error) {
                console.error("Error fetching sensor data:", error);
            }
        }

        // Function to update chart data
        function updateChart(data) {

            // Update isoChart data
            isoChart.data.datasets[0].data = [];
            isoChart.data.datasets[1].data = [];
            isoChart.data.datasets[2].data = [];
            isoChart.data.datasets[3].data = [];

            data.forEach(item => {
                const timestamp = new Date(item.sensor_timestamp);
                isoChart.data.datasets[0].data.push({ x: timestamp, y: item.data.pleasantness_intg });
                isoChart.data.datasets[1].data.push({ x: timestamp, y: item.data.pleasantness_inst });
                isoChart.data.datasets[2].data.push({ x: timestamp, y: item.data.eventfulness_intg });
                isoChart.data.datasets[3].data.push({ x: timestamp, y: item.data.eventfulness_inst });
            });

            isoChart.update();

            /*
            // Update sources chart data
            // Here we will dynamically create datasets for each source detected, and we might need to remove some as well
            const listOfSources = []
            for (let i = 0; i < data.length; i++) {
                const sources = data[i].data.sources;
                Object.keys(sources).forEach(source => {
                    if (!listOfSources.includes(source)) {
                        listOfSources.push(source);
                    }
                });
            }
            

      

            const exampleDataPoint = data[0];

            if (exampleDataPoint === undefined) {
                sensorChart.data.datasets = []
                sensorChart.update();
                return;
            }

            const datasetSourcesMap = {}
            const sourcesChartColors = ['red', 'orange', 'purple', 'brown', 'pink', 'gray', 'black', 'cyan', 'magenta', 'yellow', 'lime', 'teal', 'indigo', 'violet', 
            'fuchsia', 'gold', 'darkorange', 'darkred', 'darkgreen', 'darkblue', 'darkviolet', 'darkcyan', 'darkmagenta', 'darkyellow', 'darklime', 'darkteal', 
            'darkindigo', 'darkfuchsia', 'darkgold', 'darkgray', 'darkblack', 'darkpink', 'darkbrown', 'darkpurple', 'darkorange', 'darkred']
            Object.keys(exampleDataPoint.data.sources).forEach((source, index) => {
                datasets.push({
                    label: 'Source ' + source,
                    data: [],
                    borderColor: sourcesChartColors[index % sourcesChartColors.length],
                    fill: false,
                });
                datasetSourcesMap[source] = index + 4;
            });
            sensorChart.data.datasets = datasets;

            // Add data to the datasets
            data.forEach(item => {
                const timestamp = new Date(item.sensor_timestamp);
                Object.keys(datasetSourcesMap).forEach((source, index) => {
                    sensorChart.data.datasets[index].data.push({ x: timestamp, y: item.data.sources[source] });
                });
            });

            // Update the chart to reflect changes
            sensorChart.update();*/
        }

        // Fetch data every 1 second to simulate real-time updates
        fetchSensorData()
        setInterval(fetchSensorData, 3000);

    </script>
</body>
</html>