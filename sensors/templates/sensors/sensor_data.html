<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sensor Data for {{ sensor_id }}</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/moment@2.29.4/min/moment.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-moment@1.0.0"></script>
    <style>
        #chart-container {
            width: 80%;
            margin: auto;
            padding-top: 20px;
        }
    </style>
</head>
<body>
    <h1>Data for Sensor: {{ sensor_id }}</h1>

    <h2>Sensor Data:</h2>

    <form method="get">
        <label for="start_date">Start Date:</label>
        <input type="date" id="start_date" name="start_date" value="{{ start_date|date:"Y-m-d" }}">
        
        <label for="end_date">End Date:</label>
        <input type="date" id="end_date" name="end_date" value="{{ end_date|date:"Y-m-d" }}">
        
        <button type="submit">Filter</button>
    </form>

    <table border="1">
        <tr>
            <th>Sensor timestamp</th>
            <th>Location</th>
            <th>Data</th>
        </tr>
        {% for data in sensor_data %}
        <tr>
            <td>{{ data.sensor_timestamp }}</td>
            <td>{{ data.location }}</td>
            <td>{{ data.data }}</td>
        </tr>
        {% empty %}
        <tr>
            <td colspan="3">No data available for this sensor in the given date range.</td>
        </tr>
        {% endfor %}
    </table>

    <h2>Real-time data:</h2>
    <div id="chart-container">
        <label for="timeRange">Select Time Range:</label>
        <select id="timeRange" onchange="fetchSensorData();">
            <option value="1">Last Minute</option>
            <option value="60" selected>Last Hour</option>
            <option value="720">Last 12 Hours</option>
            <option value="1440">Last 24 Hours</option>
        </select>
        <canvas id="sensorChart"></canvas>
    </div>

    <script type="text/javascript">
        const sensorId = "{{ sensor_id }}"; // Replace with the specific sensor ID or make it dynamic 
        
        // Initialize Chart.js chart
        const ctx = document.getElementById('sensorChart').getContext('2d');
        const sensorChart = new Chart(ctx, {
            type: 'line',
            data: {
                datasets: []
            },
            options: {
                scales: {
                    x: {
                        type: 'time',
                        time: {
                            unit: 'minute'
                        },
                        title: {
                            display: true,
                            text: 'Time'
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'Value'
                        }
                    }
                },
                animation: {
                    duration: 0
                }
            }
        });
        
        // Function to fetch data and update the chart
        async function fetchSensorData() {

            const selectedRange = parseInt(document.getElementById("timeRange").value);
            const currentTime = new Date();
            const startTime = new Date(currentTime - selectedRange * 60 * 1000); // Convert minutes to milliseconds
            
            sensorChart.options.scales.x.min = startTime;
            sensorChart.options.scales.x.max = currentTime;
            
            // Add "start_date" and "end_date" parameters to the apiUrl following this format: .../?start_date=2023-10-01T00:00:00Z&end_date=2025-10-10T23:59:59Z
            // API endpoint to get sensor data filtered by sensor ID and time range
            const currentTimeWithTimezone = new Date(currentTime.getTime() - (currentTime.getTimezoneOffset() * 60 * 1000))
            const startTimeWithTimezone = new Date(startTime.getTime() - (startTime.getTimezoneOffset() * 60 * 1000))
            const apiUrl = "{{ api_endpoint_url }}" + sensorId + '/time-range/?start_date=' + startTimeWithTimezone.toISOString() + '&end_date=' + currentTimeWithTimezone.toISOString();
            try {
                const response = await fetch(apiUrl);
                const data = await response.json();
                updateChart(data);
            } catch (error) {
                console.error("Error fetching sensor data:", error);
            }
        }

        // Function to update chart data
        function updateChart(data) {

            // Create new datasets for chart dynamically according to the data received
            // Dynamically create datasets with sources from the first data point
            const datasets = [
                { label: 'Pleasantness', data: [], borderColor: 'blue', fill: false },
                { label: 'Eventfulness', data: [], borderColor: 'green', fill: false },
            ];

            const exampleDataPoint = data[0];

            if (exampleDataPoint === undefined) {
                sensorChart.data.datasets = []
                sensorChart.update();
                return;
            }

            const datasetSourcesMap = {}
            const sourcesChartColors = ['red', 'orange', 'purple', 'brown', 'pink', 'gray', 'black', 'cyan', 'magenta', 'yellow', 'lime', 'teal', 'indigo', 'violet', 
            'fuchsia', 'gold', 'darkorange', 'darkred', 'darkgreen', 'darkblue', 'darkviolet', 'darkcyan', 'darkmagenta', 'darkyellow', 'darklime', 'darkteal', 
            'darkindigo', 'darkfuchsia', 'darkgold', 'darkgray', 'darkblack', 'darkpink', 'darkbrown', 'darkpurple', 'darkorange', 'darkred']
            Object.keys(exampleDataPoint.data.sources).forEach((source, index) => {
                datasets.push({
                    label: 'Source ' + source,
                    data: [],
                    borderColor: sourcesChartColors[index % sourcesChartColors.length],
                    fill: false,
                });
                datasetSourcesMap[source] = index + 2;
            });
            sensorChart.data.datasets = datasets;

            // Add data to the datasets
            data.forEach(item => {
                const timestamp = new Date(item.sensor_timestamp);
                const timestampWithTimezone = new Date(timestamp.getTime() + (timestamp.getTimezoneOffset() * 60 * 1000))
                sensorChart.data.datasets[0].data.push({ x: timestampWithTimezone, y: item.data.pleasantness });
                sensorChart.data.datasets[1].data.push({ x: timestampWithTimezone, y: item.data.eventfulness });
                Object.keys(datasetSourcesMap).forEach((source, index) => {
                    sensorChart.data.datasets[index].data.push({ x: timestampWithTimezone, y: item.data.sources[source] });
                });
            });

            // Update the chart to reflect changes
            sensorChart.update();
        }

        // Fetch data every 1 second to simulate real-time updates
        fetchSensorData()
        setInterval(fetchSensorData, 3000);

    </script>
</body>
</html>